// === API SOLO para Revisi贸n / Pago de Facturas (POST + GET) ===

// Configuraci贸n global
const SPREADSHEET_ID = '19N7UER1RUKHcrzLKWHBpZtCFzjk_JfieNQ7DSeIijn8';
const TEMPLATE_SPREADSHEET_ID = SPREADSHEET_ID;
const TEMPLATE_SHEET_NAME     = 'Liquidacion';

// ndices de columna (1-based) en hoja "Reportes"
const COL = {
  ESTADO:     17,  // Q
  FONDO:      18,  // R (ya no se usa para pagos)
  FECHA_PAGO: 19   // S
};

// Abrimos una sola vez las hojas
const ss            = SpreadsheetApp.openById(SPREADSHEET_ID);
const sheetReportes = ss.getSheetByName('Reportes');

// Utils
const trim = v => (v ?? '').toString().trim();
function parseBool(x){ return x===true || x==="true" || x===1 || x==="1"; }
function json(o){ return ContentService.createTextOutput(JSON.stringify(o)).setMimeType(ContentService.MimeType.JSON); }

// Asegura la hoja "Otros Cargos" con las columnas requeridas
function ensureOtrosCargosSheet(){
  let sh = ss.getSheetByName("Otros Cargos");
  if (!sh) {
    sh = ss.insertSheet("Otros Cargos");
    sh.getRange(1,1,1,4).setValues([["ID_PAGO","MONTO","TIPO","FECHA"]]);
  } else {
    // Opcional: asegurar encabezados si estuviera vac铆a
    if (sh.getLastRow() < 1) {
      sh.getRange(1,1,1,4).setValues([["ID_PAGO","MONTO","TIPO","FECHA"]]);
    }
  }
  return sh;
}

/**
 * doPost: Revisi贸n/Pago
 *  - Pago puntual (compat): { fila, fechaPago, idPago? }  -> Q="Pagada", S=fecha, ID_PAGO (si existe)
 *  - Actualizar estado: { actualizarEstado:true|"true"|1, fila, nuevoEstado } (+Fecha de Revision si aplica)
 *  - Pago lote: { accion:"pagoLote", filas:[...], fechaPago:"YYYY-MM-DD", idPago:"PAGO-...", cargos:[{tipo,monto,fecha?},...] }
 */


function doPost(e) {
  try {
    if (!e?.postData?.contents) throw new Error("No se recibi贸 contenido POST v谩lido.");
    const data = JSON.parse(e.postData.contents);

    // === 1) Pago puntual (compat) ===
    if (data.fila && data.fechaPago && !data.accion) {
      const fila = parseInt(data.fila, 10);
      if (!fila) throw new Error("Fila inv谩lida para pago puntual.");

      const headers = sheetReportes.getRange(1,1,1,sheetReportes.getLastColumn()).getValues()[0].map(h => trim(h));
      const colIdPago = headers.indexOf("ID_PAGO") !== -1 ? (headers.indexOf("ID_PAGO") + 1) : null;

      const lock = LockService.getScriptLock(); lock.waitLock(30000);
      try {
        sheetReportes.getRange(fila, COL.ESTADO).setValue("Pagada");
        sheetReportes.getRange(fila, COL.FECHA_PAGO).setValue(trim(data.fechaPago));
        if (colIdPago && trim(data.idPago)) sheetReportes.getRange(fila, colIdPago).setValue(trim(data.idPago));
      } finally { lock.releaseLock(); }
      return json({ status: "OK", pago: true });
    }

    // === 2) Actualizar estado + Fecha de Revisi贸n ===
    if (parseBool(data.actualizarEstado)) {
      const fila = parseInt(data.fila, 10);
      const nuevoEstado = trim(data.nuevoEstado);
      if (!fila || !nuevoEstado) throw new Error("Datos incompletos para actualizar estado.");

      const lock = LockService.getScriptLock(); lock.waitLock(30000);
      let fechaRevisionSet = null;
      try {
        const estadoPrevio = trim(sheetReportes.getRange(fila, COL.ESTADO).getValue());
        sheetReportes.getRange(fila, COL.ESTADO).setValue(nuevoEstado);

        if (estadoPrevio === "Registrada" && nuevoEstado === "Revisada") {
          const headers = sheetReportes.getRange(1,1,1,sheetReportes.getLastColumn()).getValues()[0].map(h => trim(h));
          const idx0 = headers.findIndex(h => h === "Fecha de Revision");
          if (idx0 !== -1) {
            const now = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss");
            sheetReportes.getRange(fila, idx0 + 1).setValue(now);
            fechaRevisionSet = now;
          }
        }
      } finally { lock.releaseLock(); }
      return fechaRevisionSet ? json({ status:"OK", actualizado:true, fechaRevision:fechaRevisionSet })
                              : json({ status:"OK", actualizado:true });
    }

    // === 3) Pago en lote (+ Otros Cargos) ===
    if (trim(data.accion) === "pagoLote") {
      const filas = Array.isArray(data.filas) ? data.filas.map(n => parseInt(n,10)).filter(Boolean) : [];
      const fechaPago = trim(data.fechaPago);
      const idPago    = trim(data.idPago);
      const cargos    = Array.isArray(data.cargos) ? data.cargos : [];
      if (!filas.length || !fechaPago || !idPago) throw new Error("Datos incompletos para pagoLote (filas, fechaPago, idPago).");

      const headers = sheetReportes.getRange(1,1,1,sheetReportes.getLastColumn()).getValues()[0].map(h => trim(h));
      const idxIdPago0 = headers.indexOf("ID_PAGO");
      if (idxIdPago0 === -1) throw new Error("No existe la columna exacta 'ID_PAGO' en la hoja Reportes.");
      const colIdPago = idxIdPago0 + 1;

      const lock = LockService.getScriptLock(); lock.waitLock(30000);
      try {
        filas.forEach(fila => {
          sheetReportes.getRange(fila, COL.ESTADO).setValue("Pagada");
          sheetReportes.getRange(fila, COL.FECHA_PAGO).setValue(fechaPago);
          sheetReportes.getRange(fila, colIdPago).setValue(idPago);
        });
      } finally { lock.releaseLock(); }

      // Guardar Otros Cargos (con COD_TRANSACCION)
      let cargosGuardados = 0;
      if (cargos.length) {
        let hojaCargos = ss.getSheetByName("Otros Cargos");
        if (!hojaCargos) {
          hojaCargos = ss.insertSheet("Otros Cargos");
          hojaCargos.getRange(1,1,1,5).setValues([["ID_PAGO","MONTO","TIPO","FECHA","COD_TRANSACCION"]]);
        } else if (hojaCargos.getLastRow() < 1) {
          hojaCargos.getRange(1,1,1,5).setValues([["ID_PAGO","MONTO","TIPO","FECHA","COD_TRANSACCION"]]);
        }

        const headersC = hojaCargos.getRange(1, 1, 1, Math.max(5, hojaCargos.getLastColumn())).getValues()[0].map(h => trim(h));
        function idx(name){
          let i = headersC.indexOf(name);
          if (i === -1) {
            hojaCargos.insertColumnAfter(hojaCargos.getLastColumn());
            const newCol = hojaCargos.getLastColumn();
            hojaCargos.getRange(1, newCol).setValue(name);
            headersC.push(name);
            i = headersC.length - 1;
          }
          return i + 1;
        }
        const COL_IDP   = idx("ID_PAGO");
        const COL_MONTO = idx("MONTO");
        const COL_TIPO  = idx("TIPO");
        const COL_FECHA = idx("FECHA");
        const COL_COD   = idx("COD_TRANSACCION");

        const tz  = Session.getScriptTimeZone();
        const hoy = Utilities.formatDate(new Date(), tz, "yyyy-MM-dd");
        const colsTotal = headersC.length;

        const rowsToAppend = cargos.map(c => {
          const row = new Array(colsTotal).fill("");
          row[COL_IDP - 1]   = idPago;
          row[COL_MONTO - 1] = Number(c.monto) || 0;
          row[COL_TIPO  - 1] = trim(c.tipo);
          row[COL_FECHA - 1] = trim(c.fecha) || fechaPago || hoy;
          row[COL_COD   - 1] = trim(c.codigo || "");
          return row;
        });

        if (rowsToAppend.length) {
          const startRow = hojaCargos.getLastRow() + 1;
          hojaCargos.getRange(startRow, 1, rowsToAppend.length, colsTotal).setValues(rowsToAppend);
          cargosGuardados = rowsToAppend.length;
        }
      }

      return json({ status:"OK", pagoLote:true, filas: filas.length, idPago, cargos: cargosGuardados });
    }

// === 4) Actualizar estado en LOTE (simple, como pagoLote) ===
if (trim(data.accion) === "actualizarEstadoLote") {
  const filas = Array.isArray(data.filas) ? data.filas.map(n => parseInt(n,10)).filter(Boolean) : [];
  const nuevoEstado = trim(data.nuevoEstado);
  if (!filas.length || !nuevoEstado) {
    throw new Error("Datos incompletos para actualizarEstadoLote (filas, nuevoEstado).");
  }

  // Columna "Fecha de Revision"
  const headers = sheetReportes.getRange(1,1,1,sheetReportes.getLastColumn()).getValues()[0].map(h => trim(h));
  const idxFechaRev = headers.indexOf("Fecha de Revision");
  const colFechaRev = idxFechaRev !== -1 ? (idxFechaRev + 1) : null;

  // Timestamp 煤nico (texto)
  const now = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss");

  // Agrupa filas contiguas para minimizar llamadas
  filas.sort((a,b)=>a-b);
  const tramos = [];
  let ini = filas[0], ant = filas[0];
  for (let i=1;i<filas.length;i++){
    const r = filas[i];
    if (r === ant + 1) { ant = r; continue; }
    tramos.push([ini, ant]);
    ini = ant = r;
  }
  tramos.push([ini, ant]);

  const lock = LockService.getScriptLock(); lock.waitLock(30000);
  let updated = 0;
  try {
    tramos.forEach(([a,b])=>{
      const len = b - a + 1;

      // Escribe ESTADO (bloque por tramo)
      const outEstados = new Array(len).fill([nuevoEstado]);
      sheetReportes.getRange(a, COL.ESTADO, len, 1).setValues(outEstados);

      // Escribe FECHA DE REVISION (bloque por tramo)
      if (nuevoEstado === "Revisada" && colFechaRev) {
        const outFechas = new Array(len).fill([now]);
        sheetReportes.getRange(a, colFechaRev, len, 1).setValues(outFechas);
      }
      updated += len;
    });
  } finally {
    lock.releaseLock();
  }

  return json({ status:"OK", actualizadoLote:true, filas: updated, nuevoEstado });
}

    // Helpers locales
    function fmtDateYMD(v){
      const tz = Session.getScriptTimeZone();
      if (v instanceof Date) return Utilities.formatDate(v, tz, "yyyy-MM-dd");
      const d = new Date(v);
      if (!isNaN(d.getTime())) return Utilities.formatDate(d, tz, "yyyy-MM-dd");
      return String(v || "");
    }

    // === 5) Generar Liquidaci贸n (ISV vac铆o, filas din谩micas, encabezados y pie) ===
    if (trim(data.accion) === "generarLiquidacion") {
      const filas = Array.isArray(data.filas) ? data.filas.map(n => parseInt(n,10)).filter(Boolean) : [];
      if (!filas.length) return json({ ok:false, message:"No hay filas seleccionadas." });

      // --- Lectura de Reportes ---
      const sheet = sheetReportes;
      const lastCol = sheet.getLastColumn();
      const headers = sheet.getRange(1,1,1,lastCol).getValues()[0].map(h => trim(h));
      const H = Object.fromEntries(headers.map((h,i)=>[h, i+1]));
      const cv = (row, name) => { const c = H[name]; return c ? row[c-1] : ""; };

      const selRange = sheet.getRange(Math.min(...filas), 1, Math.max(...filas)-Math.min(...filas)+1, lastCol).getValues();
      const fila2row = {};
      selRange.forEach((row, i)=> fila2row[i + Math.min(...filas)] = row);

      // --- Construcci贸n de l铆neas ---
      const lineas = [];
      const idsPago = new Set();

      filas.forEach(fr => {
        const row = fila2row[fr]; if (!row) return;
        const estado = trim(cv(row,"Estado")); if (estado !== "Pagada") return;

        const fecha    = cv(row,"Fecha");
        const numero   = cv(row,"Numero de Factura"); // EXACTO
        const comercio = cv(row,"Nombre del comercio");
        const total    = Number(cv(row,"Total Gastado")) || 0;
        const placa    = trim(cv(row,"Placa"));
        const idp      = trim(cv(row,"ID_PAGO")); if (idp) idsPago.add(idp);

        const concepto = `ABASTECIMIENTO DE COMBUSTIBLE PARA EL VEHCULO CON PLACA-${placa||""}`;
        lineas.push({ tipo:"FACTURA", fecha:fmtDateYMD(fecha), numero:trim(numero), comercio:trim(comercio),
                      concepto, centro:"33000028", cuenta:"61040005", total });
      });

      // Otros Cargos por ID_PAGO
      const shCargos = ss.getSheetByName("Otros Cargos");
      if (shCargos && idsPago.size) {
        const last = shCargos.getLastRow();
        if (last >= 2) {
          const hc = shCargos.getRange(1,1,1, shCargos.getLastColumn()).getValues()[0].map(h=>trim(h));
          const C = Object.fromEntries(hc.map((h,i)=>[h,i]));
          const rows = shCargos.getRange(2,1,last-1, shCargos.getLastColumn()).getValues();
          rows.forEach(r => {
            const idp = trim(r[C["ID_PAGO"] ?? -1] ?? ""); if (!idp || !idsPago.has(idp)) return;
            const monto = Number(r[C["MONTO"] ?? -1] ?? 0) || 0;
            const tipo  = trim(r[C["TIPO"] ?? -1] ?? "");
            const fecha = trim(r[C["FECHA"] ?? -1] ?? "");
            const cod   = trim(r[C["COD_TRANSACCION"] ?? -1] ?? "");
            lineas.push({ tipo:"OTRO", fecha:fmtDateYMD(fecha), numero:cod,
                          comercio:"Transacci贸n Bancaria", concepto: tipo || "Otros cargos",
                          centro:"21000000", cuenta:"63010006", total:monto });
          });
        }
      }

      if (!lineas.length) return json({ ok:false, message:"No hay datos para liquidaci贸n." });

// --- Preparar Spreadsheet temporal ---
const srcSS = SpreadsheetApp.openById(TEMPLATE_SPREADSHEET_ID);
const srcSh = srcSS.getSheetByName(TEMPLATE_SHEET_NAME);
if (!srcSh) return json({ ok:false, message:`No existe la hoja plantilla '${TEMPLATE_SHEET_NAME}'.` });

const tmpSS = SpreadsheetApp.create(`LIQUIDACION_${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyyMMdd_HHmmss")}`);
const tmpSh = srcSh.copyTo(tmpSS).setName("Liquidacion");
const defSh = tmpSS.getSheets().find(s=>s.getSheetId() !== tmpSh.getSheetId());
if (defSh) tmpSS.deleteSheet(defSh);

//  Compartir el archivo temporal para evitar "Solicitar acceso"
const file = DriveApp.getFileById(tmpSS.getId());

// Opci贸n A: cualquiera con el enlace (si tu Workspace lo permite)
file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);

// Opci贸n B (alternativa): solo usuarios de tu dominio con el enlace
// file.setSharing(DriveApp.Access.DOMAIN_WITH_LINK, DriveApp.Permission.VIEW);

// (Opcional) dar un peque帽o respiro para que propaguen permisos
Utilities.sleep(300);

// === Escribir encabezados (A:B mergido, valor en C) ===
const encabezados = {
  "No. ACREEDOR:":                        trim(data.headers?.noAcreedor || ""),
  "FECHA DE SOLICITUD:":                  trim(data.headers?.fechaSolicitud || Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd")),
  "REA O DEPARTAMENTO SOLICITANTE:":     trim(data.headers?.area || ""),
  "SECTOR:":                               trim(data.headers?.sector || ""),
  "NOMBRE COMPLETO COLABORADOR:":         trim(data.headers?.colaborador || ""),
  "MOTIVO DE LIQUIDACIN POR ANTICIPO:":  trim(data.headers?.motivo || "")
};
const maxRows = Math.max(tmpSh.getMaxRows(), tmpSh.getLastRow());
const colA = tmpSh.getRange(1,1,maxRows,1).getValues().map(r => trim(r[0]));
function setRightOnColumnC(lbl, val){
  const idx = colA.findIndex(v => v === lbl);
  if (idx !== -1) { tmpSh.getRange(idx+1, 3).setValue(val); return true; }
  return false;
}
Object.keys(encabezados).forEach(k => setRightOnColumnC(k, encabezados[k]));

// === Tambi茅n escribir el nombre en el PIE (谩rea firmas) ===
const colaboradorPie = encabezados["NOMBRE COMPLETO COLABORADOR:"] || "";
if (colaboradorPie) {
  setRightOnColumnC("NOMBRE COMPLETO DEL COLABORADOR:", colaboradorPie);
  setRightOnColumnC("NOMBRE COMPLETO COLABORADOR:", colaboradorPie);
}

// --- Detalle: filas din谩micas + formato correcto ---
const startRow = 18;   // primera fila del detalle
const colsOut  = 9;    // A..I

// Matriz de salida (SIN ISV: G=TOTAL, H=vac铆o, I=TOTAL)
const out = lineas.map(x => {
  const total = Number(x.total)||0;
  const antes = total;  // VALOR ANTES DE ISV = TOTAL
  const isv   = "";     // ISV vac铆o
  return [ x.fecha||"", x.numero||"", x.comercio||"", x.concepto||"", x.centro||"", x.cuenta||"", antes, isv, total ];
});

// Localizar fila de "TOTAL A PAGAR"
const colA2 = tmpSh.getRange(1,1,tmpSh.getMaxRows(),1).getValues().map(r => trim(r[0]));
let totalRow = colA2.findIndex(v => v === "TOTAL A PAGAR");
totalRow = (totalRow === -1) ? Math.max(tmpSh.getLastRow(), startRow + 12) + 1 : (totalRow + 1);

const capacidad = Math.max(0, totalRow - startRow);
const faltan = Math.max(0, out.length - capacidad);

if (faltan > 0) {
  tmpSh.insertRowsBefore(totalRow, faltan);
  totalRow += faltan; // se desplaz贸
}

// Escribir valores y formatear bloque con la primera fila de detalle
tmpSh.getRange(startRow, 1, out.length, colsOut).setValues(out);
tmpSh.getRange(startRow, 1, out.length, 1).setNumberFormat("yyyy-mm-dd");
const tpl = tmpSh.getRange(startRow, 1, 1, colsOut);
const fullDetailRange = tmpSh.getRange(startRow, 1, out.length, colsOut);
tpl.copyTo(fullDetailRange, {formatOnly:true});

// --- URL XLSX del temporal ---
const url = `https://docs.google.com/spreadsheets/d/${tmpSS.getId()}/export?format=xlsx`;
return json({ ok:true, fileUrl:url, lineas: out.length });

    }

    // === Acciones no soportadas ===
    return json({ status:"ERROR", message:"Acci贸n no soportada en este endpoint (solo revisi贸n/pago)." });

  } catch (err) {
    Logger.log(err);
    return json({ status:"ERROR", message: err.message });
  }
}



/**
 * doGet: devuelve facturas cuando ?leerFacturas=true
 * + Soporta filtro opcional ?estados=Revisada,Pagada (CSV o repetido)
 *    - Acepta tanto ?estados=A,B como ?estados=A&estados=B
 */

// === Helpers de fecha (NUEVO: filtros por rango) ===
function toMs_(v){
  if (v == null || v === "") return null;
  if (v instanceof Date && !isNaN(v.getTime())) return v.getTime();
  if (typeof v === "number") {
    const d = new Date(v);
    if (!isNaN(d.getTime())) return d.getTime();
  }
  const s = String(v).trim();
  if (!s) return null;

  // yyyy-mm-dd
  let m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (m) {
    const d = new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]));
    return isNaN(d.getTime()) ? null : d.getTime();
  }

  // yyyy-mm-dd HH:mm:ss
  m = s.match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2}):(\d{2})$/);
  if (m) {
    const d = new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]), Number(m[4]), Number(m[5]), Number(m[6]));
    return isNaN(d.getTime()) ? null : d.getTime();
  }

  const d2 = new Date(s);
  return isNaN(d2.getTime()) ? null : d2.getTime();
}
function startOfDayMs_(ms){ const d=new Date(ms); d.setHours(0,0,0,0); return d.getTime(); }
function endOfDayMs_(ms){ const d=new Date(ms); d.setHours(23,59,59,999); return d.getTime(); }

function parseRangeParams_(e, fromKey, toKey){
  const fromRaw = e?.parameter?.[fromKey];
  const toRaw   = e?.parameter?.[toKey];
  const fromMs0 = toMs_(fromRaw);
  const toMs0   = toMs_(toRaw);
  const fromMs = (fromMs0 != null) ? startOfDayMs_(fromMs0) : null;
  const toMs   = (toMs0 != null) ? endOfDayMs_(toMs0) : null;
  if (fromMs == null && toMs == null) return null;
  if (fromMs != null && toMs != null && fromMs > toMs) return { from: toMs, to: fromMs };
  return { from: fromMs, to: toMs };
}
function inRange_(valueMs, range){
  if (!range) return true;
  if (valueMs == null) return false;
  if (range.from != null && valueMs < range.from) return false;
  if (range.to != null && valueMs > range.to) return false;
  return true;
}

/**
 * doGet: devuelve facturas cuando ?leerFacturas=true
 * + Soporta filtro opcional ?estados=Revisada,Pagada (CSV o repetido)
 * + (NUEVO) Soporta rangos:
 *    - ?desde=YYYY-MM-DD&hasta=YYYY-MM-DD        (Fecha factura)
 *    - ?revDesde=YYYY-MM-DD&revHasta=YYYY-MM-DD  (Fecha de Revision)
 */
function doGet(e) {

  // === 1) Otros Cargos: total global ===
  if (e.parameter.otrosCargos === 'total') {
    const sh = ss.getSheetByName('Otros Cargos');
    if (!sh) return json({ ok:true, totalOtrosCargos: 0 });

    const last = sh.getLastRow();
    if (last < 2) return json({ ok:true, totalOtrosCargos: 0 });

    // Columna B = MONTO
    const values = sh.getRange(2, 2, last - 1, 1).getValues(); // [[50],[40],...]
    const total = values.reduce((acc, row) => {
      const v = row[0];
      return Number.isFinite(v) ? acc + v : acc + (Number(v) || 0);
    }, 0);

    return json({ ok:true, totalOtrosCargos: total });
  }

  // === 2) Otros Cargos: totales por ID_PAGO (para agrupaci贸n por ID_PAGO) ===
  if (e.parameter.otrosCargos === 'byId') {
    const sh = ss.getSheetByName('Otros Cargos');
    if (!sh) return json({ ok:true, byId: {} });

    const last = sh.getLastRow();
    if (last < 2) return json({ ok:true, byId: {} });

    // IDs solicitados: acepta repetidos (?ids=A&ids=B) o CSV (?ids=A,B)
    let idsReq = [];
    if (e.parameters && Array.isArray(e.parameters.ids)) {
      e.parameters.ids.forEach(s => { idsReq = idsReq.concat(String(s).split(',').map(trim)); });
    } else if (e.parameter && e.parameter.ids) {
      idsReq = String(e.parameter.ids).split(',').map(trim);
    }
    idsReq = idsReq.filter(Boolean);

    // Si no recibimos IDs, evita escanear toda la hoja
    if (!idsReq.length) return json({ ok:true, byId: {} });

    // Localizar columnas por encabezado (tolerante al orden)
    const headerRow = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0].map(h => trim(h));
    const idxIdPago = headerRow.indexOf('ID_PAGO');
    const idxMonto  = headerRow.indexOf('MONTO');
    if (idxIdPago === -1 || idxMonto === -1) return json({ ok:true, byId: {} });

    // Leer solo columnas necesarias (ID_PAGO, MONTO)
    const cMin = Math.min(idxIdPago + 1, idxMonto + 1);
    const cMax = Math.max(idxIdPago + 1, idxMonto + 1);
    const numCols = cMax - cMin + 1;
    const offId = (idxIdPago + 1) - cMin;
    const offMo = (idxMonto  + 1) - cMin;

    const rows = sh.getRange(2, cMin, last - 1, numCols).getValues();
    const filter = new Set(idsReq);

    const map = {};
    for (const r of rows) {
      const id = trim(r[offId]);
      if (!id || !filter.has(id)) continue;
      const v = r[offMo];
      const monto = Number.isFinite(v) ? v : (Number(v) || 0);
      map[id] = (map[id] || 0) + monto;
    }

    return json({ ok:true, byId: map });
  }

  // === 3) Lectura de facturas ===
  if (e.parameter.leerFacturas !== 'true') {
    return ContentService
      .createTextOutput(JSON.stringify({ status: 'ERROR', message: 'Petici贸n GET no v谩lida.' }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  // (NUEVO) Rangos opcionales
  const rangoFactura  = parseRangeParams_(e, "desde", "hasta");
  const rangoRevision = parseRangeParams_(e, "revDesde", "revHasta");

  // Leer todo el rango de "Reportes"
  const data = sheetReportes.getDataRange().getValues();
  if (!data || data.length === 0) return json([]); // vac铆o

  // Cabeceras + filas
  const headers = data.shift().map(h => trim(h));

  // ndices de columnas de fecha (tolerante a nombres)
  const idxFechaFactura = (()=>{
    const names = ["Fecha","Fecha Factura","FechaFactura","FECHA"];
    for(const n of names){ const i=headers.indexOf(n); if(i!==-1) return i; }
    return -1;
  })();
  const idxFechaRevision = (()=>{
    const names = ["Fecha de Revision","Fecha de Revisi贸n","FechaRevision","Fecha Revisada"];
    for(const n of names){ const i=headers.indexOf(n); if(i!==-1) return i; }
    return -1;
  })();

  let filas = data.map((row, i) => {
    const obj = {};
    headers.forEach((h, j) => obj[h] = row[j]);
    obj.fila = i + 2; // fila real 1-based
    return obj;
  });

  // --- Filtro por estados (opcional) ---
  let estadosFiltro = [];
  if (e.parameters && Array.isArray(e.parameters.estados)) {
    e.parameters.estados.forEach(s => {
      estadosFiltro = estadosFiltro.concat(String(s).split(",").map(trim));
    });
  } else if (e.parameter && e.parameter.estados) {
    estadosFiltro = String(e.parameter.estados).split(",").map(trim);
  }
  estadosFiltro = estadosFiltro.filter(Boolean);

  if (estadosFiltro.length) {
    const objetivos = new Set(estadosFiltro);
    filas = filas.filter(r => objetivos.has(trim(r.Estado || "")));
  }

  // --- (NUEVO) Filtro por FECHA FACTURA ---
  if (rangoFactura) {
    if (idxFechaFactura === -1) {
      filas = [];
    } else {
      const colName = headers[idxFechaFactura];
      filas = filas.filter(r => inRange_(toMs_(r[colName]), rangoFactura));
    }
  }

  // --- (NUEVO) Filtro por FECHA REVISION ---
  if (rangoRevision) {
    if (idxFechaRevision === -1) {
      filas = [];
    } else {
      const colName = headers[idxFechaRevision];
      filas = filas.filter(r => inRange_(toMs_(r[colName]), rangoRevision));
    }
  }

  return ContentService
    .createTextOutput(JSON.stringify(filas))
    .setMimeType(ContentService.MimeType.JSON);
}
