// === API SOLO para Revisión / Pago de Facturas (POST + GET) ===

// Configuración global
const SPREADSHEET_ID = '19N7UER1RUKHcrzLKWHBpZtCFzjk_JfieNQ7DSeIijn8';

// Índices de columna (1-based) en hoja "Reportes"
const COL = {
  ESTADO:     17,  // Q
  FONDO:      18,  // R
  FECHA_PAGO: 19   // S
};

// Abrimos una sola vez las hojas
const ss            = SpreadsheetApp.openById(SPREADSHEET_ID);
const sheetReportes = ss.getSheetByName('Reportes');

// Utils
const trim = v => (v ?? '').toString().trim();
function parseBool(x){ return x===true || x==="true" || x===1 || x==="1"; }
function json(o){ return ContentService.createTextOutput(JSON.stringify(o)).setMimeType(ContentService.MimeType.JSON); }

// ==================================
// Helpers NUEVOS (filtro y paginación)
// ==================================
function norm(s){ return (s ?? "").toString().trim(); }

function parseDateFlexible(s){
  // Admite 'yyyy-MM-dd' y 'yyyy-MM-dd HH:mm:ss'
  if (!s) return null;
  const t = s.toString().trim();
  const iso = t.length === 10 ? (t + " 00:00:00") : t;
  const safe = iso.replace(" ", "T");
  const d = new Date(safe);
  return isNaN(d.getTime()) ? null : d;
}
function startOfDay(d){ return new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0,0,0,0); }
function endOfDay(d){ return new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23,59,59,999); }

function rangoMesActual(){
  const now = new Date();
  const desde = new Date(now.getFullYear(), now.getMonth(), 1, 0,0,0,0);
  const hasta = new Date(now.getFullYear(), now.getMonth()+1, 0, 23,59,59,999);
  return { desde, hasta };
}

function getFechaColIndex(headers){
  // Ajusta esta lista si tu encabezado real de fecha es otro
  const FECHA_CANDIDATOS = [
    "Fecha",
    "Fecha Factura",
    "Fecha de la Factura",
    "Fecha Facturación"
  ];
  const H = headers.map(norm);
  for (let name of FECHA_CANDIDATOS){
    const i0 = H.findIndex(h => h === name);
    if (i0 !== -1) return i0; // 0-based
  }
  return -1;
}

// ==================================
// POST: Revisión / Pago (igual al tuyo, con pequeño refactor estético)
// ==================================
/**
 * doPost: SOLO revisión/pago
 *  - Pago puntual: { fondoPeriodo, fechaPago, fila }
 *  - Actualizar estado: { actualizarEstado:true|"true"|1, fila, nuevoEstado }
 *    -> OPTIMIZADO: si se setea "Fecha de Revision", se retorna en la respuesta
 */
function doPost(e) {
  try {
    if (!e?.postData?.contents) throw new Error("No se recibió contenido POST válido.");
    const data = JSON.parse(e.postData.contents);

    // 1) Pago puntual (Q, R, S)
    if (data.fondoPeriodo && data.fechaPago && data.fila) {
      const fila = parseInt(data.fila, 10);
      if (!fila) throw new Error("Fila inválida para pago puntual.");

      const lock = LockService.getScriptLock(); lock.waitLock(30000);
      try {
        sheetReportes.getRange(fila, COL.ESTADO, 1, 3)
                     .setValues([["Pagada", data.fondoPeriodo, data.fechaPago]]);
      } finally {
        lock.releaseLock();
      }

      return json({ status: "OK", pago: true });
    }

    // 2) Actualizar estado (Col Q) + Fecha de Revision (solo Registrada -> Revisada)
    if (parseBool(data.actualizarEstado)) {
      const fila = parseInt(data.fila, 10);
      const nuevoEstado = trim(data.nuevoEstado);
      if (!fila || !nuevoEstado) throw new Error("Datos incompletos para actualizar estado.");

      const lock = LockService.getScriptLock(); lock.waitLock(30000);
      let fechaRevisionSet = null; // ← guardamos si se establece
      try {
        const estadoPrevio = trim(sheetReportes.getRange(fila, COL.ESTADO).getValue());
        sheetReportes.getRange(fila, COL.ESTADO).setValue(nuevoEstado);

        if (estadoPrevio === "Registrada" && nuevoEstado === "Revisada") {
          // Buscar columna por encabezado "Fecha de Revision"
          const headers = sheetReportes.getRange(1,1,1,sheetReportes.getLastColumn()).getValues()[0].map(h => trim(h));
          const idx0 = headers.findIndex(h => h === "Fecha de Revision");
          if (idx0 !== -1) {
            // TIP: si quieres ISO puro: "yyyy-MM-dd'T'HH:mm:ss"
            const now = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss");
            sheetReportes.getRange(fila, idx0 + 1).setValue(now); // 1-based
            fechaRevisionSet = now;
          }
        }
      } finally {
        lock.releaseLock();
      }

      // Respuesta optimizada: si seteamos fecha, la devolvemos para que el front no recargue todo
      if (fechaRevisionSet) {
        return json({ status: "OK", actualizado: true, fechaRevision: fechaRevisionSet });
      }
      return json({ status: "OK", actualizado: true });
    }

    // Si no coincide con ninguna acción soportada por Revisión/Pago
    return json({ status: "ERROR", message: "Acción no soportada en este endpoint (solo revisión/pago)." });

  } catch (err) {
    Logger.log(err);
    return json({ status: "ERROR", message: err.message });
  }
}

// ==================================
// GET: lectura con filtro por fecha y paginación (compatibilidad mantenida)
// ==================================
/**
 * doGet: devuelve facturas cuando ?leerFacturas=true
 *
 * Extensiones:
 * - ?mesActual=true               → si no se pasa desde/hasta, usa el mes en curso
 * - ?desde=yyyy-MM-dd[ HH:mm:ss]  → fecha inicio
 * - ?hasta=yyyy-MM-dd[ HH:mm:ss]  → fecha fin
 * - ?page=1&pageSize=500          → paginación (pageSize máx 2000; por defecto 500)
 *
 * Compatibilidad:
 * - Si solo llamas ?leerFacturas=true (sin los nuevos params), devuelve TODO como antes.
 */
function doGet(e) {
  if (e.parameter.leerFacturas !== 'true') {
    return ContentService
      .createTextOutput(JSON.stringify({ status: 'ERROR', message: 'Petición GET no válida.' }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  // --- Parámetros opcionales ---
  const p = e.parameter || {};
  const wantMesActual = p.mesActual === 'true';

  const pageSizeRaw = parseInt(p.pageSize, 10);
  const pageRaw     = parseInt(p.page, 10);
  const pageSize    = (!isNaN(pageSizeRaw) && pageSizeRaw > 0) ? Math.min(pageSizeRaw, 2000) : 500;
  const page        = (!isNaN(pageRaw)     && pageRaw     > 0) ? pageRaw : 1;

  let dDesde = parseDateFlexible(p.desde);
  let dHasta = parseDateFlexible(p.hasta);

  // Si no mandan rango pero piden mes actual, o nada → por defecto mes actual
  const noRango = (!p.desde && !p.hasta);
  if ((!dDesde || !dHasta) && (wantMesActual || noRango)) {
    const r = rangoMesActual();
    dDesde = r.desde;
    dHasta = r.hasta;
  }

  // Normaliza bordes de día
  if (dDesde) dDesde = startOfDay(dDesde);
  if (dHasta) dHasta = endOfDay(dHasta);

  // --- Lee toda la hoja una sola vez ---
  const data = sheetReportes.getDataRange().getValues();
  if (!data || data.length === 0) {
    return json({ status: "OK", rows: [], page, pageSize, total: 0 });
  }
  const headers = data.shift().map(norm);

  // Identifica columna de fecha de la factura
  const fechaIdx0 = getFechaColIndex(headers);

  // Mapea filas → objetos
  let rows = data.map((row, i) => {
    const obj = {};
    headers.forEach((h, j) => obj[h] = row[j]);
    obj.fila = i + 2; // fila real 1-based
    return obj;
  });

  // --- Filtro por fecha (si hay columna de fecha y rango válido) ---
  const tieneRangoValido = dDesde && dHasta && fechaIdx0 !== -1;
  if (tieneRangoValido) {
    const hFecha = headers[fechaIdx0];
    const tMin = dDesde.getTime();
    const tMax = dHasta.getTime();
    rows = rows.filter(r => {
      const v = r[hFecha];
      if (!v) return false;
      const d = (v instanceof Date) ? v : parseDateFlexible(v);
      if (!d) return false;
      const t = d.getTime();
      return t >= tMin && t <= tMax;
    });
  }

  // --- Orden: más reciente primero (si hay fecha) ---
  if (fechaIdx0 !== -1) {
    const hFecha = headers[fechaIdx0];
    rows.sort((a,b) => {
      const da = (a[hFecha] instanceof Date) ? a[hFecha] : parseDateFlexible(a[hFecha]);
      const db = (b[hFecha] instanceof Date) ? b[hFecha] : parseDateFlexible(b[hFecha]);
      const ta = da ? da.getTime() : 0;
      const tb = db ? db.getTime() : 0;
      return tb - ta;
    });
  }

  // Si NO se pidió rango/mesActual (compat) → ¿devolver todo sin paginar?
  // Para mantener compat rígida, si NO hay desde/hasta/mesActual en la query original,
  // devolvemos TODO, como hacía el contrato original:
  const callerPidioCompatTotal = (!p.mesActual && !p.desde && !p.hasta);
  if (callerPidioCompatTotal) {
    return ContentService
      .createTextOutput(JSON.stringify(rows))
      .setMimeType(ContentService.MimeType.JSON);
  }

  // --- Paginación ---
  const total = rows.length;
  const start = (page - 1) * pageSize;
  const end   = Math.min(start + pageSize, total);
  const pageRows = (start < total) ? rows.slice(start, end) : [];

  // Respuesta paginada
  return ContentService
    .createTextOutput(JSON.stringify({
      status: "OK",
      rows: pageRows,
      page,
      pageSize,
      total
    }))
    .setMimeType(ContentService.MimeType.JSON);
}
